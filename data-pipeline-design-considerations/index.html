<!doctype html>
<html lang="en" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<meta name="generator" content="Docusaurus v2.0.0-beta.20">
<link rel="alternate" type="application/rss+xml" href="/rss.xml" title="Bostata RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/atom.xml" title="Bostata Atom Feed"><title data-rh="true">Data Pipeline Design Considerations | Bostata</title><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://your-docusaurus-test-site.com/data-pipeline-design-considerations"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="Data Pipeline Design Considerations | Bostata"><meta data-rh="true" name="description" content="There are many factors to consider when designing data pipelines, which include disparate data sources, dependency management, interprocess monitoring, quality control, maintainability, and timeliness. Toolset choices for each step are incredibly important, and early decisions have tremendous implications on future successes. The following post is meant to be a reference to ask the right questions from the start of the design process, instead of halfway through. In terms of the V-Model of systems engineering, it is intended to fall between the “high level design” and “detailed design” steps:"><meta data-rh="true" property="og:description" content="There are many factors to consider when designing data pipelines, which include disparate data sources, dependency management, interprocess monitoring, quality control, maintainability, and timeliness. Toolset choices for each step are incredibly important, and early decisions have tremendous implications on future successes. The following post is meant to be a reference to ask the right questions from the start of the design process, instead of halfway through. In terms of the V-Model of systems engineering, it is intended to fall between the “high level design” and “detailed design” steps:"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2018-02-09T00:00:00.000Z"><meta data-rh="true" property="article:tag" content="data,pipeline,design"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://your-docusaurus-test-site.com/data-pipeline-design-considerations"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/data-pipeline-design-considerations" hreflang="en"><link data-rh="true" rel="alternate" href="https://your-docusaurus-test-site.com/data-pipeline-design-considerations" hreflang="x-default"><link rel="stylesheet" href="/assets/css/styles.9b0d8e9b.css">
<link rel="preload" href="/assets/js/runtime~main.2fc05b10.js" as="script">
<link rel="preload" href="/assets/js/main.5316f307.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region"><a href="#" class="skipToContent_ZgBM">Skip to main content</a></div><nav class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Navigation bar toggle" class="navbar__toggle clean-btn" type="button" tabindex="0"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--light_TfLj"><img src="/img/logo.svg" alt="My Site Logo" class="themedImage_W2Cr themedImage--dark_oUvU"></div><b class="navbar__title text--truncate">Bostata</b></a></div><div class="navbar__items navbar__items--right"><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/">Blog</a><div class="toggle_S7eR colorModeToggle_vKtC"><button class="clean-btn toggleButton_rCf9 toggleButtonDisabled_Pu9x" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_v35p"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_nQuB"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_dLyj"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div class="main-wrapper"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_TMXw thin-scrollbar" aria-label="Blog recent posts navigation"><div class="sidebarItemTitle_V4zb margin-bottom--md">Recent posts</div><ul class="sidebarItemList_uHd5 clean-list"><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/staying-fresh-with-freshness-tables">Staying Fresh with Freshness Tables</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/268-billion-events-with-snowplow-snowflake-at-cargurus">268 Billion Events With Snowplow and Snowflake at Cargurus</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/how-to-install-and-configure-snowsql">How To Install and Configure SnowSQL</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/gdpr-for-engineers-what-you-need-to-know">GDPR for Engineers - What You Need to Know</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/gdpr-for-engineers-what-is-personal-data">GDPR for Engineers - What is Personal Data?</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/client-side-instrumentation-for-under-one-dollar">Client-side instrumentation for under $1 per month. No servers necessary.</a></li><li class="sidebarItem_spIe"><a class="sidebarItemLink_eqrF" href="/why-your-company-should-own-its-own-data">Why Your Company Should Own Its Own Data</a></li><li class="sidebarItem_spIe"><a aria-current="page" class="sidebarItemLink_eqrF sidebarItemLinkActive_XZSJ" href="/data-pipeline-design-considerations">Data Pipeline Design Considerations</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="blogPostTitle_rzP5" itemprop="headline">Data Pipeline Design Considerations</h1><div class="blogPostData_Zg1s margin-vert--md"><time datetime="2018-02-09T00:00:00.000Z" itemprop="datePublished">February 9, 2018</time> · <!-- -->14 min read</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_FlmR"><div class="avatar margin-bottom--sm"><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><span itemprop="name">Jake</span></div></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>There are many factors to consider when designing data pipelines, which include disparate data sources, dependency management, interprocess monitoring, quality control, maintainability, and timeliness. Toolset choices for each step are incredibly important, and early decisions have tremendous implications on future successes. The following post is meant to be a reference to ask the right questions from the start of the design process, instead of halfway through. In terms of the V-Model of systems engineering, it is intended to fall between the “high level design” and “detailed design” steps:</p><p><img loading="lazy" alt="v-curve" src="/assets/images/v-curve-fcddea49428eb9920bb7c910e69d8bc6.png" width="1348" height="754" class="img_E7b_"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="preliminary-considerations">Preliminary Considerations<a class="hash-link" href="#preliminary-considerations" title="Direct link to heading">​</a></h2><p>Before selecting toolsets, and certainly before writing any code, there are many subsystem factors and expectations to be taken into account. When designing production-facing data pipelines, you will need to take these factors into consideration.</p><h1>Data: Origin, Type, and Timeliness</h1><h3 class="anchor anchorWithStickyNavbar_mojV" id="origin">Origin<a class="hash-link" href="#origin" title="Direct link to heading">​</a></h3><p>First and foremost, the origin of the data in question must be well understood, and that understanding must be shared across engineers to minimize downstream inconsistencies. Assumptions concerning data structure and interpretation are very hard to work around once they are baked into reports and/or managerial decisions, so it’s incredibly important to get this step right.</p><p>Secondly, an investigation into how to get data from the production application must be performed. Can application data be queried/ exported from the production database, in bulk, without detrimentally affecting the user experience? Are you sure about that? Spoiler alert: you&#x27;ll probably want to set up replication on the production database before the export process is hardened.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="type">Type<a class="hash-link" href="#type" title="Direct link to heading">​</a></h3><p>The type of data involved is another important aspect of system design, and data typically falls into one of two categories: event-based and entity data. Event-based data is denormalized, and is used to describe actions over time, while entity data is normalized (in a relational db, that is) and describes the state of an entity at the current point in time. In Ralph Kimball’s data warehousing terminology, event-based data corresponds to facts while entity data corresponds to dimensions.</p><p>At first glance, event-based data lends itself to incremental ingestion via high-water marks, while entity data lends itself to bulk ingestion or change data capture. If the normalized data model includes a modified_at (or equivalent) column on entity tables, and it is trustworthy, various entity data can also be ingested incrementally to relieve unnecessary load. Ideally, data should always be incrementally ingested and processed, but reality says that is not always an option.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="timeliness">Timeliness<a class="hash-link" href="#timeliness" title="Direct link to heading">​</a></h3><p>How quickly must data be gathered from the production system, and how quickly must it be processed? Data pipelining methodologies will vary widely depending on the desired speed of data ingestion and processing, so this is a very important question to answer prior to building the system. Ideally, event-based data should be ingested almost instantaneously to when it is generated, while entity data can either be ingested incrementally (ideally) or in bulk. If all data ingestion processes are incremental, making the process faster is simply just a matter of running the particular job more often. Therefore, that should be the goal.</p><p>Kafka is a very good option for realtime website activity tracking as it was created by Linkedin to do exactly that. It offers the ability for messages to be replayed, incorporates extensive fault-tolerance, can be partitioned, etc. RabbitMQ and Snowplow are other very suitable options, and solve similar problems in slightly different ways.</p><p>For pulling data in bulk from various production systems, toolset choices vary widely, depending on what technologies are implemented at the source. In Postgresql, these choices include <code>COPY (some_query) TO STDOUT WITH CSV HEADER</code>, a dblink from one database to another, streaming replication via the write-ahead log, or using a <code>pg_dump --table sometable --no-privileges | some_file.sql</code> script. Redshift&#x27;s functionality is very similar, but the system uses S3 as an intermediary to <code>UNLOAD (&#x27;some_query&#x27;) TO &#x27;s3://bucket&#x27;</code>.</p><h1>Storage Mechanisms</h1><p>When it comes to choosing a storage mechanism, the largest factors to be considered include the volume of data and the query-ability of said data (if &quot;query-ability&quot; is indeed a word). If a limited amount of volume is expected, or data is pre-aggregated elsewhere, many storage options will suffice. If incoming data is to be collected in sufficiently large volume or if the storage mechanism must allow for downstream exploratory querying, storage options decrease significantly. If queries are defined beforehand and the volume of data is the limiting factor, Hadoop is a solid alternative. If a high volume of data is to be collected but will be queried in an exploratory way, Redshift is a better alternative. The parity to older versions of Postgres (8.0.2) and the fact that the surface looks/ feels like a regular Postgres database make it very easy to learn and utilize.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="questions-to-ask-when-choosing-a-storage-mechanism">Questions to ask when choosing a storage mechanism<a class="hash-link" href="#questions-to-ask-when-choosing-a-storage-mechanism" title="Direct link to heading">​</a></h3><ul><li>What level of volume is expected? 200M rows in a single table makes Postgres crawl, especially if it isn’t partitioned. If it is partitioned, queries must be altered accordingly to avoid scanning each partition.</li><li>Will data be exploratorily queried, or are queries defined already and will be semi-static in the future? Tool options and distribution/ sorting strategies will need to be altered accordingly.</li><li>What level of maintenance do you wish to perform? Ideally, engineering resources will go to setting up the system, and future maintenance will be minimal and/or only performed as absolutely necessary.</li><li>Will dashboarding/ analysis tools be pointed at the raw data, or will data be aggregated and moved elsewhere?</li><li>Who will be accessing the data? A system like Hadoop is not ideal for junior analysts with limited SQL/bash knowledge.</li></ul><h1>Language Selection</h1><p>For the sake of developmental speed, maintainability, and parity with various pipelining tools, Python is a very solid language selection. The key component to this is consistency across the system - especially when the team is small. Usually the “Python is slow” argument can be overcome by Python’s multiprocessing or concurrent.futures modules, or by only processing as much as is absolutely necessary. Or by waiting for Intel to optimize for Python. But that&#x27;s a different story.</p><p>Almost every single data pipelining tool has a Python client, and the language allows for future flexibility while maintaining speed of initial development. It also allows for rapid onboarding of new developers, efficient testing with mock, remote bash execution/deployment with fabric, and much more. Companies that continually process enormous amounts of data use Python extensively, and there’s a reason they have selected it as language of choice. Lastly, Airbnb’s Airflow and Spotify’s Luigi are both conveniently written in Python.</p><h1>ETL Dependency Management</h1><p>Dependency management is easy to conceptualize, but a little more difficult to manage across multiple worker nodes or <em>cough</em> a Docker Swarm. This is where tools like Luigi, Airflow, and even Jenkins for remote execution scheduling come into play.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="time-based-scheduling">Time-based scheduling<a class="hash-link" href="#time-based-scheduling" title="Direct link to heading">​</a></h3><p>In short, pipeline jobs should never be executed via time-based scheduling. If a one-hour job that is scheduled at 8am fails, all downstream jobs should be aware of that failure and downstream execution should be modified accordingly. If the job starts taking longer than one hour due to increased volume or processing requirements, downstream jobs should be aware and only execute after the upstream job has successfully run. Time-based scheduling cannot efficiently handle either condition, and requires engineers continuously modify the schedule. This wastes time, and is completely unnecessary.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="single-vs-multiple-dependencies">Single vs. multiple dependencies<a class="hash-link" href="#single-vs-multiple-dependencies" title="Direct link to heading">​</a></h3><p>If an ETL job only has one upstream dependency, Jenkins is a perfectly suitable tool for linking jobs together. It is quite straight-forward to set up, allows for remote execution on multiple nodes, and is simply a matter of passing the necessary bash script to the job configuration. It also allows for one job to kick off multiple downstream tasks after execution (ie, “load the data you just aggregated to a foreign database, and let the world know it’s happening”).</p><p>If an ETL job has multiple upstream dependencies, Jenkins becomes pretty clumsy. It is certainly possible to do so, but it’s not exactly pretty. Luigi and Airflow shine in this respect, because both are built to handle many upstream dependencies for a single job (DAG style).</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="visualizing-dependencies">Visualizing Dependencies<a class="hash-link" href="#visualizing-dependencies" title="Direct link to heading">​</a></h3><p>Jenkins doesn’t even try to visualize the acyclic graph of nested dependencies, while Luigi and Airflow both do. Visualizing the relationships between interconnected jobs is a huge time saver, and allows for the system to grow easily without overloading the ones who built it (and therefore slowing down future development).</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="separation-of-concerns">Separation of Concerns<a class="hash-link" href="#separation-of-concerns" title="Direct link to heading">​</a></h3><p>Jenkins is exceptional at job scheduling and handling a limited set of single dependencies, and that is all. Luigi is extremely good at multiple dependency handling and visualization, but it doesn’t even attempt to handle scheduling execution of the initial job in the acyclic graph. Airflow tries to do everything including job duration monitoring, plotting job execution overlap via Gantt charts, scheduling, and dependency management. In my opinion (I warned you I was opinionated), job durations and overlap are ideally tracked and handled elsewhere, alongside other pipeline instrumentation.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="balancing-dependency-management-with-job-overload">Balancing dependency management with job overload<a class="hash-link" href="#balancing-dependency-management-with-job-overload" title="Direct link to heading">​</a></h3><p>If a job dependency tool is used, every minuscule item of the ETL process should be not wrapped in a task. For example, if ten tables are to be exported from a remote database, and all must be exported before downstream tasks run, there should not be an import job for each of the ten tables. There should be one job that imports all the designated tables. This allows for the dependency graph to remain clean, code to be well-written and easily maintainable, etc.</p><h1>Fault Tolerance</h1><h3 class="anchor anchorWithStickyNavbar_mojV" id="persistence-in-message-based-ingestion">Persistence in message-based ingestion<a class="hash-link" href="#persistence-in-message-based-ingestion" title="Direct link to heading">​</a></h3><p>If incoming event data is message-based, a key aspect of system design centers around the inability to lose messages in transit, regardless of what point the ingestion system is in. Message queues with delivery guarantees are very useful for doing this, since a consumer process can crash and burn without losing data and without bringing down the message producer. Alternatively, the producer process can crash and burn, and the consumer will see nothing but the fact that no new messages have come in. Messages in transit should always be persisted to disk (if space and time allows) so that if the broker/queue goes down, it can be brought back up without losing data.</p><p>If done right, this method of data ingestion is extremely fault-tolerant and scalable. There are some key differences between various pub/sub systems (persistence, replayability, distributed commit log vs. queue), but that is a separate conversation.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="stop-on-error-in-bulk-processing">Stop-on-error in bulk processing<a class="hash-link" href="#stop-on-error-in-bulk-processing" title="Direct link to heading">​</a></h3><p>Fault tolerance is a key aspect of any data pipeline, and downstream tasks should always be aware of upstream tasks failing. Data pipelining is one place where exceptions should not always be handled in code, and engineers should know about any error in the system immediately. The main place exceptions should be handled is when retrying a task for a designated period of time (or number of retries/ exponential back-off). This is so that downstream jobs don’t run and mistakenly cause additional harm to data quality. The system should stop immediately when a fault is detected if downstream jobs depend on it.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="idempotence-and-replayability">Idempotence and replayability<a class="hash-link" href="#idempotence-and-replayability" title="Direct link to heading">​</a></h3><p>Bulk pipeline jobs should always be created so that they are able to be re-run immediately in case of failure, and entirely idempotent. No matter how many times a particular job is run, it should always produce the same output with a given input, and should not persist duplicate data to the destination. Want math?</p><p><code>f(f(x)) = f(x)</code></p><h1>Architectural separation of concerns</h1><p>In short, a production web application should never be dependent on a reporting database and/or data warehouse. This creates an unnecessary dependency which is inflexible for maintenance and increases the level of risk.</p><h1>Pipeline Monitoring</h1><p>As with any system, individual steps should be extensively instrumented and monitored. If they are not, it is nearly impossible to eliminate personal opinion and accurately determine the facts of system operation. A good starting point is to measure the time which a particular job started, stopped, total runtime, state of completion, and any pertinent error messages.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="start-and-stop-time">Start and stop time<a class="hash-link" href="#start-and-stop-time" title="Direct link to heading">​</a></h3><p>This one is pretty straight-forward, as the difference is used to calculate runtime. Logging start time of jobs is very useful on its own, however, since it adds a linear aspect to job execution (even if the jobs are executed in parallel). When debugging a step of the pipeline, it’s very helpful to see when the jobs were executed, in order by which they were kicked off. It also allows for easy visualization if need be.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="runtime">Runtime<a class="hash-link" href="#runtime" title="Direct link to heading">​</a></h3><p>This metric is also obvious yet incredibly powerful for determining the current state of the world, proactive system improvements, and early warning signs for future problems. The following insight is realized, simply by measuring runtime:</p><ul><li>Determination of system bottlenecks</li><li>Early-warning signs for jobs trending upwards, relative to other jobs</li><li>Statistically-benchmarked improvements</li><li>Determination of the effects on a particular system from external variables (server, network, etc)</li><li>Job completion and error logging</li></ul><p>Pipeline instrumentation not only allows for efficient debugging, early warning signs, and proactive improvements to the system, but it also allows the engineers to see progress over time. It also can be very easily used to expose various system statistics to outside parties, so that system scale can be easily and effectively communicated.</p><h1>Pipeline Monitoring Tools</h1><p>Monitoring each portion of the pipeline, as well as aggregate statistics, can be done in a variety of ways. Graphite was built to handle this type of data, but even a table that stores system metrics is much better than nothing all all. The combination of instrumentation decorators (in Python at least) and various signals being sent to Graphite is ideal. InfluxDB is another way to build instrumentation directly into your data pipelines.</p><p>For system instrumentation visualizations, I highly recommend Grafana.</p><h1>Accessibility and Visualization</h1><h3 class="anchor anchorWithStickyNavbar_mojV" id="tools">Tools<a class="hash-link" href="#tools" title="Direct link to heading">​</a></h3><p>There are many tools out there for accessing and visualizing data. For data exploration and team collaboration, tools like Wagon are great. For dashboarding and sharing data, Periscope is a good choice. When selecting a tool, it is ideal if the code involved is not proprietary to that particular tool. That is, the entire company shouldn’t be bound to a tool, simply because it uses a sql variant that is too painful to rewrite. Another key consideration is the ease of use for non-technical or semi-technical people. In order to proliferate a data-centric mindset across the organization, the tool must be relatively straight-forward to use and build upon. Also, it doesn’t really make sense to build out a proprietary visualization tool when time-series or bar charts powered by sql will suffice.</p><h3 class="anchor anchorWithStickyNavbar_mojV" id="database-role-topology">Database role topology<a class="hash-link" href="#database-role-topology" title="Direct link to heading">​</a></h3><p>When analysts and other dashboarding tools are allowed access to the same database as your various ETL tools, it is of utmost importance to grant them the minimum permissions necessary to perform the designated job function. In short, an analyst should never be able to inadvertently UPDATE event records coming from a production system, and a dashboarding tool should never be allowed the privileges necessary to issue a DROP TABLE statement. A flexible role topology allows the freedom for each of these groups to do what they need to do, but no more.</p><h1>System constraints</h1><p>There are many constraints to consider, and pipeline creation largely depends on data sources, deployment environment, associated networks, etc. If the source data/ production application is all on AWS, it doesn’t make sense to spin up a physical server in the office for the pipeline. AWS offers plenty of tools for moving data within the system itself (as well as the cost implications when keeping AWS-generated data inside AWS). Alternatively, if the application lives on a VM, hosted in the office, it makes sense to spin up another VM on the same subnet for pipelining. Since constraints are entirely dependent on the existing system in which to gather data from, it would simply be impossible to cover all them in a simple paragraph. That&#x27;s where a little human creativity goes a long way.</p><h1>Conclusion</h1><p>In conclusion, there are a plethora of options to consider when building out a data pipelining system. There are many pros and cons to each alternative, and this document outlines some of the major factors involved. I hope it helps, and at the very least, provokes questions and thoughtful system design. If thought through from the start, many system inefficiencies can be avoided, and the power associated with efficient, reliable data collection can rapidly come to fruition.</p></div><footer class="row docusaurus-mt-lg blogPostDetailsFull_h6_j"><div class="col"><b>Tags:</b><ul class="tags_XVD_ padding--none margin-left--sm"><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/data">data</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/pipeline">pipeline</a></li><li class="tag_JSN8"><a class="tag_hD8n tagRegular_D6E_" href="/tags/design">design</a></li></ul></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Blog post page navigation"><a class="pagination-nav__link pagination-nav__link--prev" href="/why-your-company-should-own-its-own-data"><div class="pagination-nav__sublabel">Newer Post</div><div class="pagination-nav__label">Why Your Company Should Own Its Own Data</div></a></nav></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2022 Built with Docusaurus.</div></div></div></footer></div>
<script src="/assets/js/runtime~main.2fc05b10.js"></script>
<script src="/assets/js/main.5316f307.js"></script>
</body>
</html>